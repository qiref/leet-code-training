package bit_arithmetic

//一个数组中，只有一种数出现奇数次，另外的数出现偶数次，求出现奇数次的数？
//（要求时间复杂度为O(n)，空间复杂度为 O(1)）

// 异或运算的性质
// ^异或运算，相同为0，不同为1，还可以理解为无进位相加
// 1. 0 和任意数异或，都为任意数，并任意数与自身异或，都为0
// 2. 交换结合律，a^b=b^a ; a^b^c = a^c^b
// 3. 同一批数异或结果都一样
func printOddTimesNum1(arr []int) int {
	eor := 0
	for _, v := range arr {
		// 遍历数组, int eor = 0; 把所有数都跟 eor 异或，最后的结果就是出现奇数次的数
		eor ^= v
	}
	return eor
}

//一个数组中，有两种数出现奇数次，另外的数出现偶数次，求出现奇数次的数？
//（要求时间复杂度为O(n)，空间复杂度为 O(1)）

// 继续按照上面的思路，假设这两种数为 a , b ; 那么最后的 eor 的结果一定是 a^b , 由于有两种数，a!=b , 所以 eor!=0
// 那么 a 和 b 的32位中，总会有一位不为0
// 假设第8位为1，那么a、b 在第8位上一定是不一样的，异或结果为1，那数组则可以分为第8位为1的数，和第8位为0的数，并且a、b会分别在两部分集合中；
// 并且此时，两个集合中，除 a 、b 之外，剩下的就是出现偶数次的数，这些数异或的结果是0，所以两个集合内部异或的结果，就只剩下a、b；
// eor1 去异或第8位为1的数，那最后eor1=a|b，另外一个数则是eor1^eor
func printOddTimesNum2(arr []int) (a int, b int) {
	eor1 := 0
	for _, v := range arr {
		eor1 ^= v
	}
	// eor1 = a^b ，由于a!=b, 所以eor1!=0, 那么eor1 32 位中至少会有一位为1,
	// 假设第N为是1，基于第N位，能将数组分为两个集合,
	// a 和 b 会分别分到两个集合中
	ro := eor1 & (^eor1 + 1) // eor1 找到最右边为1的数

	// eor2 只和两个集合中的一个异或，就能得到 a|b
	eor2 := 0 // 只和ro与运算为0的数异或，则结果是a|b
	for _, v := range arr {
		if v&ro == 0 {
			eor2 ^= v
		}
	}
	return eor2, eor1 ^ eor2
}
